# 3.4.2 0型和1型语法

一个任意的0型语法的识别问题是不可解的，这在形式语言学上是一个显著的成果。这意味着不会有一种算法，它接受一个任意的0型语法以及一个任意的字符串，然后在有限的时间内告诉我们这个语法是否能能生成这个字符串。可以证明这种说法，但是证明过程非常令人生畏，并且它不能提供任何能窥探到造成这种现象的原因。这是一个逆向的证明：我们能证明，如果存在这样一种算法，我们就能构造第二个算法，其能证明语法只能在永远不终止的情况下才能终止。由于这在逻辑上是不成立的，并且由于其余所有的前提在证明过程中都表明我们不得不得出一个结论就是，在我们最初的前提下，0型语法的识别器在逻辑上是不可能的。令人信服，但精神上却难以接受。完整的证明见Hopcroft and Ullman [391, pp. 182-183], or Révész [394, p. 98]。

为一定数量的0型语法构建一个识别器却是很有可能的，通过使用某种特定的技术。然而这种技术却不能对所有0型语法起效。事实上，不论我们收集了多少种技术，总会有这些技术不起作用的语法存在。在某种意义上，我们只是不能使我们的识别器足够复杂。

对于1型语法，这种情况却是完全不同的。1型语法的生成规则不能使句子形式收敛这个看似无关紧要的属性，让我们可以为自底向上的NDA构建一个至少原则上能起作用的控制机制，而不考虑语法。这个控件的内部管理包含一组可能在输入的句子中发挥作用的句子形式；它开始只包含输入的句子。For Type 1 grammars, the situation is completely different. The seemingly inconsequential property that Type 1 production rules cannot make a sentential form shrink allows us to construct a control mechanism for a bottom-up NDA that will at least work in principle, regardless of the grammar. The internal administration of this control consists of a set of sentential forms that could have played a role in the production of the input sentence; it starts off containing only the input sentence. Each move of the NDA is a reduction according to the grammar. Now the control applies all possible moves of the NDA to all sentential forms in the internal administration in an arbitrary order, and adds each result to the internal administration if it is not already there. It continues doing so until each move on each sentential form results in a sentential form that has already been found. Since no move of the NDA can make a sentential form longer (because all right-hand sides are at least as long as their left-hand sides) and since there are only a finite number of sentential forms as long as or shorter than the input string, this must eventually happen. Now we search the sentential forms in the internal administration for one that consists solely of the start symbol. If it is there, we have recognized the input string; if it is not, the input string does not belong to the language of the grammar. And if we still remember, in some additional administration, how we got this start symbol sentential form, we have obtained the parsing. All this requires a lot of book-keeping, which we are not going to discuss, since nobody does it this way anyway.

To summarize the above, we cannot always construct a parser for a Type 0 grammar, but for a Type 1 grammar we always can. The construction of a practical and reasonably efficient parser for these types of grammars is a very difficult subject on which slow but steady progress has been made during the last 40 years (see (Web)Section 18.1.1). It is not a hot research topic, mainly because Type 0 and Type 1 grammars are well-known to be human-unfriendly and will never see wide application. Yet it is not completely devoid of usefulness, since a good parser for Type 0 grammars would probably make a good starting point for a theorem prover.[^1]

The human-unfriendliness consideration does not apply to two-level grammars. Having a practical parser for two-level grammars would be marvelous, since it would allow parsing techniques (with all their built-in automation) to be applied in many more areas than today, especially where context conditions are important. The present possibilities for two-level grammar parsing are discussed in Section 15.2.3.

All known parsing algorithms for Type 0, Type 1 and unrestricted two-level grammars have exponential time dependency.

[^1]: 一个理论证明程序就是，给定一组定理或公理，在没有或极少认为干预的情况下来证明或反证这个理论的程序。

# 3.7.4 解析林语法

将解析的结果作为语法展示可能看起来很奇怪，甚至是有些令人失望的；毕竟应该从语法和字符串开始，做的所有解析工作，难道最后只是为了成为另一个语法？但是我们将看到解析林有相当多的优点。但这些优点都不明显，这可能也是为什么解析林直到上世纪八十年代才被提出，由Lang [210, 220, 31]引入。而“解析林语法”这个词似乎是被van Noord [221]首次使用。

图3.17 将图3.2 的解析树显示为一个解析林语法，而这之间的过程很有趣。对于原始语法中的每一个非终结符*A*，会从*i*的位置开始产生一个长度为*l*的段，在解析林语法中有一个非终结符*A_i_l*，以及显示*A_i_l*如何产生一个段的规则。例如，解析林语法存在的***Sum_1_5***展示了*Sum*产生了整个的输入字符串（从位置1开始，长度为5）；***Sum_1_5***有多个规则的事实表明, 解析是不明确的；两个规则显示了***Sum_1_5***产生整个输入字符串的两种可能方式。当我们使用这种语法来生成字符串时，它只生成***3+5+1***的输入字符串，但是生成了两次，由于不明确而导致。

![图1](../../img/3.7.4_1-Fig.3.17.png)

We write A_i_l rather than Ai,l because A_i_l represents the name of a grammar symbol, not a subscripted element of an entity A: there is no table or matrix A. Nor is there any relationship between A_i_l and say A_i_m: each A_i_l is a separate name of a grammar symbol.

Now for the advantages. First, parse-forest grammars implement in a graphical way the concept, already expressed less directly in the previous section, that there should be exactly one entity that describes how a given non-terminal produces a given substring of the input.

Second, it is mathematically beautiful: parsing a string can now be viewed as a function which maps a grammar onto a more specific grammar or an error value. Rather than three concepts — grammars, input strings, and parse forests — we now need only two: grammars and input strings. More practically, all software used in handling the original grammar is also available for application to the parse-forest grammar.

Third, parse-forest grammars are easy to clean up after pruning, using the algorithms from Section 2.9.5. For example, applying the disambiguation criterion used in the previous section to the rules of the grammar in Figure 3.17 identifies the first rule for Sum_1_5 as being in violation. Removing this rule and applying the grammar clean-up algorithm yields the unambiguous grammar of Figure 3.18, which corresponds to the tree in Figure 3.16.

![图2](../../img/3.7.4_2-Fig.3.18.png)

Fourth, representing infinitely ambiguous parsings is trivial: the parse-forest grammar just produces infinitely many (identical) strings. And producing infinitely many strings is exactly what grammars normally do.

And last but probably not least, it fits in very well with the interpretation of parsing as intersection, an emerging and promising approach, further discussed in Chapter 13.

Now it could be argued that parse forests and parse-forest grammars are actually the same and that the pointers in the first have just been replaced by names in the second, but that would not be fair. Names are more powerful than pointers, since a pointer can point only to one object, whereas a name can identify several objects, through overloading or non-determinism: names are multi-way pointers. More in particular, the name Sum_1_5 in Figure 3.17 identifies two rules, thus playing the role of the top OR-node in Figure 3.14. We see that in parse-forest grammars we get the AND-OR tree mechanism free of charge, since it is built into the production mechanism of grammars.
# 3.1.1 解析树的大小

A parse tree for a string of n tokens consists of n nodes belonging to the terminals, plus a number of nodes belonging to the non-terminals. Surprisingly, there cannot be more than CGn nodes belonging to non-terminals in a parse tree with n token nodes, where CG is a constant that depends on the grammar, provided the grammar has no loops. This means that the size of any parse tree is linear in the length of the input.

Showing that this is true has to be done in a number of steps. We prove it first for grammars in which all right-hand sides have length 2; these result in binary trees, trees in which each node either has two children or is a leaf (a node with no children). Binary trees have the remarkable property that all binary trees with a given number of leaves have the same number of nodes, regardless of their shapes. Next we allow grammars with right-hand sides with lengths > 2, then grammars with unit rules, and finally grammars with nullable rules.

As we said, an input string of length n consists of n token nodes. When the parse tree is not there yet, these nodes are parentless leaves. We are now going to build an arbitrary binary tree to give each of these nodes a parent, labeled with a non-terminal from the grammar. The first parent node P1 we add lowers the number of parentless nodes by 2, but now P1 is itself a parentless node; so we now have n+1 nodes of which n−2+1 = n−1 are parentless. The same happens with the second added parent node P2, regardless of whether one of its children is P1;sonow wehave n+2 nodes of which n−2 are parentless. After j steps we have n+ j nodes of which n− j are parentless and after n−1 steps we have 2n−1 nodes of which 1 is parentless. The 1 parentless node is the top node, and the parse tree is complete. So we see that when all right-hand sides have length 2, the parse tree for an input of length n contains 2n−1 nodes, which is linear in n.

If some of the right-hand sides have length > 2, fewer parent nodes may be required to construct the tree. So the total tree size may be smaller than 2n−1, which is certainly smaller than 2n.

If the grammar contains unit rules — rules of the form A→B — it is no longer true that adding a parent node reduces the number of parentless nodes: when a parentless node B gets a parent A through the rule A → B, it is no longer parentless, but the node for A now is, and, what is worse, the number of nodes has gone up by one. And it may be necessary to repeat the process, say with a rule Z → A,etc. But eventually the chain of unit rules must come to an end, say at P (so we have P →Q···Z → A → B ), or there would be a loop in the grammar. This means that P gets a parent node with more than one child node and the number of parentless nodes is reduced (or P is the top node). So the worst thing the unit rules can do is to “lengthen” each node by a constant factor Cu, the maximum length of a unit rule chain, and so the size of the parse tree is smaller than 2Cun.

If the grammar contains rules of the form A→ ε, only a finite number of εs can be recognized between each pair of adjacent tokens in the input, or there would again be a loop in the grammar. So the worst thing nullable rules can do is to “lengthen” the input by a constant factor Cn, the maximum number of εs recognized between two tokens, and the size of the parse tree is smaller than 2CnCun, which is linear in n.

If, on the other hand, the grammar is allowed to contain loops, both the above processes can introduce unbounded stretches of nodes in the parse tree, which can then reach any size.
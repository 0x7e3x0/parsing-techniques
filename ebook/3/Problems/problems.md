# 问题

Problem 3.1: Suppose all terminal symbols in a given grammar are different. Is that grammar unambiguous?

Problem 3.2: Write a program that, given a grammar G and a number n, computes the number of different parse trees with n leaves (terminals) G allows.

Problem 3.3: If you are familiar with an existing parser (generator), identify its parser components, as described on page 69.

Problem 3.4: The maze preprocessing algorithm in Section 3.5.4 eliminates all rooms with three walls; rules with two or four walls are acceptable in a deterministic maze. What about rooms with zero or one wall? How do they affect the algorithm and the result? Is it possible/useful to eliminate them too?

Problem 3.5: Construct an example in which a deterministic bottom-up parser will have to perform k actions at position k, for a certain k.

Problem 3.6: Project: There are several possible paths through the maze in Figure 3.10(b), so a maze defines a set of paths. It is easy to see that these paths form a regular set. This equates a maze to a regular grammar. Develop this analogy, for example: 1. Derive the regular grammar from some description of the maze. 2. How does the subset algorithm (Section 5.3.1) transform the maze? 3. Is it possible to generate a set of mazes so that together they define a given CF set?

Problem 3.7: Project: Study the “translate and cross out matching parentheses” parsing method of Greibach [389].

Problem 3.8: Show that a version of Figure 3.14 in which the nodes marked 2 near the top are combined represents parse trees that are not supported by the input.

Problem 3.9: Implement the backtracking algorithm sketched in Section 3.7.3.

Problem 3.10: Assume arithmetic expressions are parsed with the highly ambiguous grammar with an appropriate definition of Number. Design a criterion that will help prune the resulting parse forest to obtain the parse tree that obeys the usual precedences for the operators. For example, 4+5×6+8 should come out as ((4+(5×6))+8). Take into account that the first four operators are left-associative, but the exponentiation operator ↑ is right-associative: 6/6/6 is ((6/6)/6) but 6 ↑ 6 ↑ 6 is (6 ↑ (6 ↑ 6)).

![图1](../../img/3.12_1.png)

Problem 3.11: Research project: Some parsing problems involve extremely large CF grammar, with millions of rules. Such a grammar is generated by program and results from incorporating finite context conditions into the grammar. It is usually very redundant, containing many very similar rules, and very ambiguous. Many general CF parsers are quadratic in the size of the grammar, which for ten million rules brings in a factor of 1014. Can parsing techniques be designed that work well on such grammars? (See also Problem 4.5.)

Problem 3.12: Extensible Project: 1. A string S is balanced for a token pair (t1, t2) if #t1 = #t2 for S and #t1 ≥ #t2 for all prefixes of S, where #t is the number of occurrences of t in S or a prefix of it. A token pair (t1, t2) is a parentheses pair for a grammar G if all strings in L(G) are balanced for (t1, t2). Design an algorithm to check if a token pair (t1, t2) is a parentheses pair for a given grammar G: a) under the simplifying but reasonable assumption that parentheses pairs occur together in the right hand side of a rule (for example, as in F--->(E)), and b) in the general case.

2. A token t1 in position i in a string matches a token t2 in a position j if the string segment i+1· · · j−1 between them is balanced for (t1, t2). A parentheses pair (t1, t2) is compatible with a parentheses pair (u1,u2) if every segment between a t1 and its matching t2 in every string in L(G) is balanced for (u1,u2). Show that if (t1, t2) is compatible with (u1,u2), (u1,u2) is compatible with (t1, t2).

3. Design an algorithm to find a largest set of compatible parentheses pairs for a given grammar.

4. Use the set of parentheses pairs to structure sentences in L(G) in linear time.

5. Derive information from G about the segments of strings in L(G) that are not structured in that process, for example regular expressions.

6. Devise further techniques to exploit the parentheses skeleton of CF languages.
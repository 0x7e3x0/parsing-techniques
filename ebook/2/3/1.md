# 2.3.1 1型语法

<p>0型语法的特征是，它包含一条规则是可能将任意数目（非零）的符号转化为任意数目（可能为零）的符号。例如：</p>

**, N E ---> and N**

如上三个符号被两个符号取代。通过限制这种自由，我们引入1型语法。奇怪的是关于1型语法的，直觉上完全不同的两个定义，却很容易被证明是相同的。

### 2.3.1.1 1型语法的两个类型

<p>一种语法是*1型单调*，如果它不包含规则，左侧的符号比右侧符号更多。例如，禁止这个规则 **, N E ---> and N**.</p>

<p>一种语法是*1型上下文相关*，如果所有的规则都是上下文相关。一个规则是*上下文相关*，如果左侧只有一个符号（非终结符）被其他符号替代，然后我们把右侧的符号都找到且没有损坏且按顺序放置。例如：</p>

**Name Comma Name End ---> Name and Name End**

这就说明这个规则

<center>**Comma ---> and**</center>

可能适用，如果左侧文字是**Name**而右侧文字是**Name End**。上下文本身不受影响。替代者必须是至少一个符号长。这意味着上下文相关语法总是单调的；见2.5节。

这里是**t,d&h**例子的一个单调语法。在书写单调语法时，必须要小心绝不能多生成一个后面本来就会生成的符号。我们通过将结束标记纳入最右侧的名字来避免需要删除键鼠标记：

![图1](../../img/2.3.1_1.png)

当**EndName**是一个单独的符号时。

<p>这就是它的一个上下文相关语法。</p>

![图2](../../img/2.3.1_2.png)

<p>请注意，我们需要一个额外的非终结符逗号来产生终结符，并在正确的上下文中。</p>

单调语法和上下文相关语法时同样强大的：每一种可以由单调语法生成的语言，都可以由上下文相关语法生成，反之亦然。但它们都不如0型语法强大，也就是说，可以由0型语法可以生成任何一种1型语法都无法生成的语言。但奇怪的是没有这样的语言被人们所知道。虽然0型语法和1型语法的区别是基础层面的，而且不是Chomsky先生一时兴起的，它们之间差异的语法太复杂而不能写下来；而只能证明这差异的存在（例如Hopcroft and Ullman [391, pp. 183-184], 或 Révész [394, p. 98]）。

当然任何类型的1型语法都属于0型语法，因为1型语法是在0型语法的基础上，增加了一些限制条件推导而来。但如果将1型语法也称为0型语法就会引起混乱； But it would be confusing to call a Type 1 grammar a Type 0 grammar; it would be like calling a cat a mammal: correct but imprecise. A grammar is named after the smallest class (that is, the highest type number) in which it will still fit.

We saw that our t,d&h language, which was first generated by a Type 0 grammar, could also be generated by a Type 1 grammar. We shall see that there is also a Type 2 and a Type 3 grammar for it, but no Type 4 grammar. We therefore say that the t,d&h language is a Type 3 language, after the most restricted (and simple and amenable) grammar for it. Some corollaries of this are: A Type n language can be generated by a Type n grammar or anything stronger, but not by a weaker Type n+1 grammar; and: If a language is generated by a Type n grammar, that does not
necessarily mean that there is no (weaker) Type n+1 grammar for it. The use of a Type 0 grammar for our t,d&h language was a serious case of overkill, just for demonstration purposes.

### 2.3.1.2 Constructing a Type 1 Grammar

The standard example of a Type 1 language is the set of words that consist of equal numbers of as, bs and cs, in that order:



For the sake of completeness and to show how one writes a Type 1 grammar if one is clever enough, we shall now derive a grammar for this toy language. Starting with the simplest case, we have the rule

**0. S ---> abc**

Having obtained one instance of S, we may want to prepend more as to the beginning; if we want to remember how many there were, we shall have to append something to the end as well at the same time, and that cannot be a b or a c. We shall use a yet unknown symbol Q. The following rule both prepends and appends:

**1. S ---> aSQ**

If we apply this rule, for example, three times, we get the sentential form

**aaabcQQ**

Now, to get aaabbbccc from this, each Q must be worth one b and one c, as expected, but we cannot just write

**Q ---> bc**

because that would allow bs after the first c. The above rule would, however, be all right if it were allowed to do replacement only between a b on the left and a c on the right. There the newly inserted bc will do no harm:

**2. bQc ---> bbcc**

Still, we cannot apply this rule since normally the Qs are to the right of the c. This can be remedied by allowing a Q to hop left over a c:

**3. cQ ---> Qc**

We can now finish our derivation:



It should be noted that the above derivation only shows that the grammar will produce the right strings, and the reader will still have to convince himself that it will not generate other and incorrect strings (Problem 2.4).

The grammar is summarized in Figure 2.7. Since a derivation graph of a3b3c3



is already rather unwieldy, a derivation graph for a2b2c2 is given in Figure 2.8. The



grammar is monotonic and therefore of Type 1. It can be proved that there is no Type 2 grammar for the language; see Section 2.7.1.

Although only context-sensitive Type 1 grammars can by rights be called context-sensitive grammars (CS grammars), that name is often used even if the grammar is actually monotonic Type 1. There are no standard initials for monotonic, but MT will do.
# Problems

Problem 4.1: A stringU is a supersequence of a string S ifU can be created from S by inserting zero or more tokens from the language in arbitrary places in S. (See also Section 12.4.) a) Design an Unger parser for a grammar G that will recognize a supersequence of a string in the language generated by G. b) Do the same for a CYK parser.

Problem 4.2: A string U is a subsequence of a string S if U can be created from S by deleting zero or more tokens from arbitrary places in S. (See also Section 12.4.) 

- a) Design an Unger parser for a grammar G that will recognize a subsequence of a string in the language generated by G. 

- b) Do the same for a CYK parser.

Problem 4.3: Project: Eliminating ε-rules from a grammar greatly modifies it, and effort must be spent to undo the damage during parsing. Much of the effort can be saved by incorporating the removed εs in the modified grammar, as follows. Given a grammar like S--->aBc, B--->b|ε, we first convert it to AND-OR form, recording the original right-hand side in the name of the non-terminal. (A grammar is in AND/OR form if there are only two kinds of rules, AND-rules which specify concatenation of grammar symbols, and OR-rules which specify choice between non-terminal symbols, and there is only one rule for each non-terminal. This names the alternatives rather than the non-terminals.) This yields S--->aBc, B--->Bb|Bε, Bb--->b, Bε--->ε. Next substitute out all nullable OR-rules (the one for B in our case): S--->SaBbc|SaBεc, SaBbc--->aBbc, SaBεc--->aBεc, Bb--->b, Bε--->ε. Now substitute the rules of the form A → ε: S--->SaBbc|SaBεc, SaBbc--->aBbc, SaBεc--->ac, Bb--->b. Then when parsing SaBεc--->ac the subscript of the S tells us the real form of the right-hand side. Elaborate this idea into a complete algorithm, with parser.

Problem 4.4: Remove the unit rules from the grammar

SS ---> T
T ---> U
U ---> T

Problem 4.5: Research Project: CYK, especially in its chart parsing form, has long been a favorite of natural language parsing, but we have seen its time requirements are O(|G||Pav|n3). With some natural language grammars being very large (millions of rules), especially the generated ones, even O(|G|) is a problem, regardless of the O(|Pav|). Design a version of the CYK/chart algorithm that is better than O(|G|). Do not count on |ADJ| to be substantially smaller than |G|2, where ADJ is the set of pairs of non-terminals that occur adjacently in any right-hand side. (See also Problem 3.11.)

Problem 4.6: Project: When looking at program source code in a programming language, usually seeing two adjacent tokens is enough to get a pretty good idea of which syntactic structure we are looking at. This would eliminate many of the bottom-up hypotheses that CYK maintains. Use this idea to automatically suppress the bulk of the table entries, hopefully leaving only a limited number. This would make it an almost linear-time parser, which might be important for parsing legacy code, which comes with notoriously sloppy grammar.

Try to suppress more hypotheses of the form A → α by checking tokens that can occur just before, at the beginning of, inside, at the end of, and just after, a terminal production of A.

Problem 4.7: Formulate the inference rule for the computation of Ti,A in Section 4.3.

Problem 4.8: Draw Figures 4.8 and 4.16 using the end position of the recognized segment as the second index.

Problem 4.9: Project Determine the class of grammars for which Rus’s algorithm [28] works.

Problem 4.10: Formal Languages: Design an algorithm to transform a given grammar into one with the lowest possible number of non-terminals. This is important since the time requirements of many parsing algorithms depend on the grammar size.